/* 
 * File:   main.cpp
 * Author: stribus
 *
 * Created on 1 de Maio de 2013, 16:14
 */

#include <stdio.h>
#include <stdlib.h>
#include <fuzzy.h>
#include <iostream>
#include <sqlite3.h>
#include <string.h> 
#include <vector>


#define INSERIR "insert into hash(blocksize, hash, nome) values ( ?, ?, ?)" 
#define LOCALIZACAO_DB "/home/stribus/teste"
#define ARQUIVO_CONFIGURACAO "./vs.conf"
#define BUSCAR_TODOS_HASH "select hash from hash"
#define BUSCAR_HASH_BLOCKSIZE "select hash from hash where (blocksize >= (? / 2)) and (blocksize <= (? * 2) )"


using namespace std;


/**
 * @brief gera a hash 
 * @param nomeArquivo nome do arquivo a qual é pra gerar a hash
 * @return retorna a hash, se falhar retorna null
 */
char* geraHash (char *nomeArquivo);

int gravaDB(int blockSize,const char* assinatura,const char* identificacao);

int adicionarMalwareDB(char* nomeArquivo,char* nomeMalware);


char** getHashsDB(int blockSize);
/*
 * 
 */
int main(int argc, char** argv) {
    char* nome= NULL;
    

    if (argc > 1){
        nome = argv[1];
    } else {
        nome = "/home/stribus/instal_java.sh";
    }
      
    getHashsDB(100);
    
    
    
    return 0;
};


char* geraHash(char *nomeArquivo){
    int status;
    FILE *arquivo;
    char *resultado;
    resultado  = (char *) malloc(FUZZY_MAX_RESULT);
    
    arquivo = fopen(nomeArquivo,"rb");
    if (NULL == arquivo)
    {
        perror(nomeArquivo);
        return NULL;
    }

    printf ("Hashing file\n");
    status = fuzzy_hash_file(arquivo,resultado);
    
    if (status){
        printf ("Error during file hash\n");
        return NULL;
    }

    fclose(arquivo);
    return resultado;
};

int gravaDB(int blockSize,const char* assinatura,const char* identificacao){
    int status = 0;
    char *sql= INSERIR;
    
    sqlite3 *db = NULL;  
    sqlite3_stmt *stmt = NULL;
    
    status = sqlite3_open(LOCALIZACAO_DB, &db);
    if (status != SQLITE_OK ){
        cerr<<"erro ao conectar no banco de dados: ";
        cerr<<status;
        return(status);
    };
    
    sqlite3_prepare_v2(db, sql, -1, &stmt, 0);
    
    sqlite3_bind_int(stmt,1,blockSize);
    sqlite3_bind_text(stmt,2,assinatura,-1,NULL);
    sqlite3_bind_text(stmt,3,identificacao,-1,NULL);
    
    status = sqlite3_step(stmt);
    if (status != SQLITE_DONE){
        cerr<<"falha na gravação do banco de dados";
        cerr<< status;        
    } else {
        status= 0;
    }
    sqlite3_finalize(stmt);
    sqlite3_close(db);
    return status;
};


int adicionarMalwareDB(char* nomeArquivo,char* nomeMalware){
    char* hash= NULL;    
    char* posicaoPonto= NULL;
    char* strBlockSize= "\0\0\0\0\0\0\0\0\0\0";
    
    
    hash = geraHash(nomeArquivo);

    posicaoPonto = strchr(hash, ':');
    strncpy(strBlockSize, hash, posicaoPonto - hash);
    strBlockSize[posicaoPonto - hash]='\0';
    gravaDB(atoi(strBlockSize), hash, nomeMalware);  
    
    return 0;
};

char** getHashsDB(int blockSize){
    char* sql = NULL;
    sqlite3 *db = NULL;
    sqlite3_stmt *stmt = NULL;
    int status = 0;
    vector <string> result;
    
    status = sqlite3_open(LOCALIZACAO_DB, &db);
    if (status != SQLITE_OK ){
        cerr<<"erro ao conectar no banco de dados: ";
        cerr<<status;
        return NULL;
    };
    
    
    if (blockSize > 0){
        sql = BUSCAR_HASH_BLOCKSIZE;
        sqlite3_prepare(db, sql, -1, &stmt, 0);
        sqlite3_bind_int(stmt,1,blockSize);
        sqlite3_bind_int(stmt,2,blockSize);                
        
    } else {
        sql = BUSCAR_TODOS_HASH;
        sqlite3_prepare(db, sql, -1, &stmt, 0);
        
    }
    status =sqlite3_step(stmt);
    while ( status == SQLITE_ROW ) {
        
        result.push_back((const char*)sqlite3_column_text(stmt, 0));
        status =sqlite3_step(stmt);
    }
    cout<<result[2];
    return NULL;
};