/* 
 * File:   main.cpp
 * Author: stribus
 *
 * Created on 1 de Maio de 2013, 16:14
 */

#include <stdio.h>
#include <stdlib.h>
#include <fuzzy.h>
#include <iostream>
#include <sqlite3.h>
#include <string.h> 
#include <vector>
#include <sstream> 


#define INSERIR "insert into hash(blocksize, hash, nome) values ( ?, ?, ?)" 
#define LOCALIZACAO_DB "./assinaturas.db"
#define ARQUIVO_CONFIGURACAO "./vs.conf"
#define BUSCAR_TODOS_HASH "select hash from hash"
#define BUSCAR_HASH_BLOCKSIZE "select hash from hash where (blocksize >= (? / 2)) and (blocksize <= (? * 2) )"
#define BUSCAR_NOME "select nome from hash where hash = ?"


using namespace std;


/**
 * @brief gera a hash 
 * @param nomeArquivo nome do arquivo a qual é pra gerar a hash
 * @return retorna a hash, se falhar retorna null
 */
char* geraHash(string nomeArquivo);

/**
 * 
 * @param blockSize
 * @param assinatura
 * @param identificacao
 * @return 
 */
int gravaDB(int blockSize, const char* assinatura, const char* identificacao);

/**
 * 
 * @param nomeArquivo
 * @param nomeMalware
 * @return 
 */
int adicionarMalwareDB(string nomeArquivo, string nomeMalware);

/**
 * 
 * @param blockSize especifica o blocksize que será pesquisado
 * @return retorna um vetor com as hash entre blocksize/2  e 2*blocksize
 */
vector<string> getHashsDB(int blockSize);

/**
 * 
 * @param hash
 * @param minHomologo
 * @param maxHomologo
 * @return 
 */
string verificaHash(string hash, int minHomologo, int maxHomologo);

/**
 * 
 * @param hash
 * @return 
 */
string getNomeMalwareDB(string hash);

/**
 * 
 * @param number
 * @return 
 */
string convertInt(int number);

/*
 * 
 */
int main(int argc, char** argv) {
    int help = 0;
    int min = 30;
    int max = 100;
    string arquivo = "";
    string nome = "";
    char acao = 0;
    string hash = "";

    for (int i = 1; (argc-1) >= i; i++) {
        switch (argv[i][1]) {
            case 's':
                acao = 's';
                i++;
                arquivo = argv[i];
                break;
            case 'm': i++;
                min = atoi(argv[i]);
                break;
            case 'M': i++;
                max = atoi(argv[i]);
                break;
            case 'a': acao = 'a';
                i++;
                arquivo = argv[i];
                i++;
                nome = argv[i];
                break;
            default: help = 1;
        }
    };

    
    if (acao == 's'){
        hash = geraHash(arquivo);
        cout<<verificaHash(hash, min, max);
        cout<<endl;
    }
    if (acao == 'a'){
        if (adicionarMalwareDB(arquivo,nome) == 0){
            cout <<"malware adicionado com sucesso"<<endl<<endl;
        };
    }
    if (help) {
        cout << "armumentos invalidos\n";
        cout << "use: ";
        cout << argv[0];
        cout << " [parametros]\n";
        cout << "   -s File \t\t : escaneia um arquivo\n";
        cout << "   -m [0..100] \t\t : porcentagem mínimo de semelhança para detecção\n";
        cout << "   -M [0..100] \t\t : porcentagem máximo de semelhança para detecção\n";
        cout << "   -a file malware \t : adiciona assinatura do arquivo especificando o \"nome\"\n";
    };


    //getHashsDB(100);
    //cout<<



    return 0;
};

char* geraHash(string nomeArquivo) {
    int status;
    FILE *arquivo;
    char *resultado;
    resultado = (char *) malloc(FUZZY_MAX_RESULT);

    arquivo = fopen(nomeArquivo.data(), "rb");
    if (NULL == arquivo) {
        perror(nomeArquivo.data());
        return NULL;
    }

    printf("Hashing file\n");
    status = fuzzy_hash_file(arquivo, resultado);

    if (status) {
        printf("Error during file hash\n");
        return NULL;
    }

    fclose(arquivo);
    return resultado;
};

int gravaDB(int blockSize, const char* assinatura, const char* identificacao) {
    int status = 0;

    sqlite3 *db = NULL;
    sqlite3_stmt *stmt = NULL;

    status = sqlite3_open(LOCALIZACAO_DB, &db);
    if (status != SQLITE_OK) {
        cerr << "erro ao conectar no banco de dados: ";
        cerr << status;
        return (status);
    };

    sqlite3_prepare_v2(db, INSERIR, -1, &stmt, 0);

    sqlite3_bind_int(stmt, 1, blockSize);
    sqlite3_bind_text(stmt, 2, assinatura, -1, NULL);
    sqlite3_bind_text(stmt, 3, identificacao, -1, NULL);

    status = sqlite3_step(stmt);
    if (status != SQLITE_DONE) {
        cerr << "falha na gravação do banco de dados";
        cerr << status;
    } else {
        status = 0;
    }
    sqlite3_finalize(stmt);
    sqlite3_close(db);
    return status;
};

int adicionarMalwareDB(string nomeArquivo, string nomeMalware) {
    string hash = "\0";
    int posicaoPonto = 0;
    string strBlockSize = "\0";

    hash = geraHash((const char*) nomeArquivo.data());

    posicaoPonto = hash.find(":", 0);
    strBlockSize = hash.substr(0, posicaoPonto);
    

    return gravaDB(atoi(strBlockSize.data()), hash.data(), nomeMalware.data());;
};

vector<string> getHashsDB(int blockSize) {
    sqlite3 *db = NULL;
    sqlite3_stmt *stmt = NULL;
    int status = 0;
    vector <string> result;

    status = sqlite3_open(LOCALIZACAO_DB, &db);
    if (status != SQLITE_OK) {
        cerr << "erro ao conectar no banco de dados: ";
        cerr << status;
        result.clear();
        return result;
    };


    if (blockSize > 0) {
        sqlite3_prepare(db, BUSCAR_HASH_BLOCKSIZE, -1, &stmt, 0);
        sqlite3_bind_int(stmt, 1, blockSize);
        sqlite3_bind_int(stmt, 2, blockSize);

    } else {
        sqlite3_prepare(db, BUSCAR_TODOS_HASH, -1, &stmt, 0);

    }
    status = sqlite3_step(stmt);
    while (status == SQLITE_ROW) {

        result.push_back((const char*) sqlite3_column_text(stmt, 0));
        status = sqlite3_step(stmt);
    }

    sqlite3_finalize(stmt);
    sqlite3_close(db);
    return result;
};

string verificaHash(string hash, int minHomologo, int maxHomologo) {
    string strBlockSize = "\0";
    int posicaoPonto = 0;
    vector<string> assinaturas;
    int porcentagemSemelhanca = 0;
    string inform = "Tá limpo!";
    int maiorPorc = 0;
    
    posicaoPonto = hash.find(":", 0);
    strBlockSize = hash.substr(0, posicaoPonto);
    assinaturas = getHashsDB(atoi(strBlockSize.data()));
    //cout << assinaturas.size()<<endl;
    
    
    for (int i = 0; i < assinaturas.size(); i++) {
        porcentagemSemelhanca = fuzzy_compare(hash.data(), assinaturas[i].data());
        
        if ((porcentagemSemelhanca >= minHomologo) and (porcentagemSemelhanca <= maxHomologo)
                and (porcentagemSemelhanca > maiorPorc)) {
            inform = "Possivel Malware encontrado. ";
            inform += convertInt(porcentagemSemelhanca);
            inform += "% semelhante a ";
            inform += getNomeMalwareDB(assinaturas[i]);
            maiorPorc = porcentagemSemelhanca;
        };
    };

    return inform;
};

string getNomeMalwareDB(string hash) {
    string sql = "";
    sqlite3 *db = NULL;
    sqlite3_stmt *stmt = NULL;
    int status = 0;
    string result = "";

    status = sqlite3_open(LOCALIZACAO_DB, &db);
    if (status != SQLITE_OK) {
        cerr << "erro ao conectar no banco de dados: ";
        cerr << status;
        return result;
    };

    sqlite3_prepare_v2(db, BUSCAR_NOME, -1, &stmt, 0);
    sqlite3_bind_text(stmt, 1, hash.data(), -1, NULL);

    status = sqlite3_step(stmt);
    result = (const char*) sqlite3_column_text(stmt, 0);

    sqlite3_finalize(stmt);
    sqlite3_close(db);

    return result;

};

string convertInt(int number) {
    stringstream ss; //create a stringstream
    ss << number; //add number to the stream
    return ss.str(); //return a string with the contents of the stream
}
